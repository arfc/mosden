import openmc
from openmc.stats import Uniform, spherical_uniform, Isotropic
from openmc.model import Model
import numpy as np
import openmc.deplete
import re


batches = 10
nps = 50000
mode = 'fixed source'
seed = 1
energy_MeV = 0.0253e-6
mass_g = 3
g_cm3 = 2.3275
temperature_K = 920
fissiles = {'U235': 1.0}
xs_data = '/home/luke/projects/cross-section-libraries/endfb71/endfb71_hdf5/cross_sections.xml'
t_in: float = 5
t_ex: float = 3
t_net: float = 20
decay_times: np.ndarray[float] = np.geomspace(1e-3, 10, 5)
reprocess_locations: list[str] = ['excore']
flux = 1
chain_file = '/home/luke/github/mosden/mosden/data/unprocessed/endfb71/omcchain/chain_casl_pwr.xml'
reprocessing = {'Xe': 0.0}
repr_scale = 1.0


volume = mass_g / g_cm3
radius = (mass_g * volume / (4 * np.pi)) ** (1/3)

xs_library = openmc.data.DataLibrary.from_xml(xs_data)
xs_nuclide_list = [i['materials'][0] for i in xs_library.libraries]
pattern = re.compile(r'^[A-Z][a-z]?\d+(?:_m\d+)?$')
xs_nuclide_list = [s for s in xs_nuclide_list if pattern.match(s)]


def settings():
    settings = openmc.Settings()
    settings.batches = batches
    settings.output = {'summary': False,
                       'tallies': False}
    settings.particles = nps
    settings.run_mode = mode
    settings.seed = seed
    settings.temperature = {'default': temperature_K,
                            'method': 'interpolation'}
    settings.verbosity = 8

    source = openmc.IndependentSource()
    source.energy = Uniform(energy_MeV, energy_MeV)
    source.space = spherical_uniform(r_outer=radius)
    source.angle = Isotropic()
    source.particle = 'neutron'
    settings.source = source
    return settings


def materials():
    sample = openmc.Material()
    sample.name = 'sample'
    sample.id = 1
    for nuc, frac in fissiles.items():
        sample.add_nuclide(nuc, frac, 'wo')
    sample.set_density('g/cm3', g_cm3)
    sample.depletable = True
    sample.volume = volume
    materials = openmc.Materials([sample])
    return materials

def geometry(materials):
    sphere = openmc.Sphere(r=radius,
                           boundary_type='vacuum')
    sphere_cell = openmc.Cell(region=-sphere,
                              fill=materials[0])
    universe = openmc.Universe(cells=[sphere_cell])
    geometry = openmc.Geometry(universe)
    return geometry

def tallies():
    tallies_file = openmc.Tallies()

    mesh = openmc.RegularMesh()
    mesh.dimension = [1, 1, 1]
    mesh.lower_left = np.array([-radius, -radius, -radius])
    mesh.upper_right = np.array([radius, radius, radius])
    mesh_filter = openmc.MeshFilter(mesh)

    # Fission Rate tally    # Prompt Neutron Yield tally
    fission_tally = openmc.Tally(name='fissionrate')
    fission_tally.filters = [mesh_filter]
    fission_tally.scores = ['fission']
    fission_tally.multiply_density = True
    fission_tally.nuclides = list(set(xs_nuclide_list))
    tallies_file.append(fission_tally)

    # Delayed Neutron Yield tally
    delnu_tally = openmc.Tally(name='delnuyield')
    delnu_tally.filters = [mesh_filter]
    delnu_tally.scores = ['delayed-nu-fission']
    delnu_tally.multiply_density = True
    delnu_tally.nuclides = list(set(xs_nuclide_list))
    tallies_file.append(delnu_tally)

    # Prompt Neutron Yield tally
    delnu_tally = openmc.Tally(name='pmtnuyield')
    delnu_tally.filters = [mesh_filter]
    delnu_tally.scores = ['prompt-nu-fission']
    delnu_tally.multiply_density = True
    delnu_tally.nuclides = list(set(xs_nuclide_list))
    tallies_file.append(delnu_tally)

    # Total Neutron Yield tally
    delnu_tally = openmc.Tally(name='nuyield')
    delnu_tally.filters = [mesh_filter]
    delnu_tally.scores = ['nu-fission']
    delnu_tally.multiply_density = True
    delnu_tally.nuclides = list(set(xs_nuclide_list))
    tallies_file.append(delnu_tally)

    return tallies_file

def build_model(settings, materials, geometry, tallies):
    model = Model(geometry, materials,
                  settings, tallies)
    model.export_to_xml()
    return model


def get_times_and_rates():
    removal_indeces = list()
    timesteps = list()
    source_rates = list()
    current_time = 0
    index_counter = 0
    in_core = True
    while current_time < t_net:
        if in_core:
            t = t_in
            region = 'incore'
            source = flux
            in_core = False
        else:
            t = t_ex
            region = 'excore'
            source = 0
            in_core = True
        
        timesteps.append(t)
        if region in reprocess_locations:
            removal_indeces.append(index_counter)
        source_rates.append(source)
        current_time += t
        index_counter += 1
    
    for t in decay_times:
        timesteps.append(t)
        source_rates.append(0)
    return timesteps, source_rates, removal_indeces


def run():
    tally = tallies()
    mats = materials()
    geom = geometry(mats)
    sets = settings()
    model = build_model(sets,  mats, geom, tally)

    ts, sources, chem_times = get_times_and_rates()
    operator = openmc.deplete.CoupledOperator(model, chain_file,
                                              normalization_mode='source-rate')
    repr_obj = None
    if not np.all(np.asarray(list(reprocessing.values())) <= 0.0):
        repr_obj = openmc.deplete.transfer_rates.TransferRates(operator, model, len(ts))
        for element, rate in reprocessing.items():
            repr_obj.set_transfer_rate(mats[0], [element], rate * repr_scale,
                                       timesteps=chem_times)
            
    integrator = openmc.deplete.PredictorIntegrator(operator,
                                                    timesteps=ts,
                                                    source_rates=sources,
                                                    timestep_units='s')
    if repr_obj:
        integrator.transfer_rates = repr_obj
    integrator.integrate()
    return